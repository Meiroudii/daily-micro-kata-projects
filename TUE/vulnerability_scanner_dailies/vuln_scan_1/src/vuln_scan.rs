use std::io::{Read};
use std::net::{TcpStream};
use std::time::Duration;

#[derive(Debug)]
struct ScanResult {
    port: u16,
    open: bool,
    banner: Option<String>,
}

fn scan_port(addr: &str, port: u16) -> ScanResult {
    let target = format!("{}:{}", addr, port);

    // Try to connect with a timeout
    let stream = TcpStream::connect_timeout(
        &target.parse().unwrap(),
        Duration::from_secs(1),
    );

    match stream {
        Ok(mut stream) => {
            // Set read timeout for banner grabbing
            stream
                .set_read_timeout(Some(Duration::from_millis(500)))
                .ok();

            let mut buf = [0u8; 256];

            let banner = match stream.read(&mut buf) {
                Ok(n) if n > 0 => Some(String::from_utf8_lossy(&buf[..n]).into()),
                _ => None,
            };

            ScanResult {
                port,
                open: true,
                banner,
            }
        }
        Err(_) => ScanResult {
            port,
            open: false,
            banner: None,
        },
    }
}

fn check_vulnerabilities(results: &[ScanResult]) {
    println!("\n=== Vulnerability Checks ===");

    for r in results {
        if r.open {
            println!("- Port {} is open", r.port);

            if let Some(banner) = &r.banner {
                // Simple example check
                if banner.contains("OpenSSH_7.2") {
                    println!("  â†’ Potential outdated OpenSSH version detected");
                }
            }
        }
    }
}

/// This function is the entry point called by `main.rs`
pub fn run(target_ip: &str) {
    let ports = vec![22, 80, 443, 3306, 8080];

    println!("Scanning {}", target_ip);

    let mut results = Vec::new();

    for port in ports {
        let result = scan_port(target_ip, port);
        println!("{:?}", result);
        results.push(result);
    }

    check_vulnerabilities(&results);
}
